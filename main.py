import model.helper as helper
#import browseDb.main as browseDb
#from threading import Timer
import os
import model.user as user
from override_flask import Flask
from flask import request, send_from_directory, abort, g

app = Flask(__name__,)


@app.before_request
def before_request():
	g.notify = []  # an array that holds notifications (like non-fatal errors or important messages)

	# a variable that holds an error... if there is one (there should be 1 or 0 errors returned)
	# a error is formatted as ('title','discription')
	#	title: one word name for the error
	#	discription: text givent to the user to tell what happened/how to fix
	g.error = ()

	g.user = user.Instance()  # starts out as guest user, store user object in g (thread safe context)

	try:  # try to authenticate
		g.user.check(username=request.args['username'], token=request.args['token'], ip=request['remote_addr'])  # validate user token if username and token are supplied
	except KeyError:
		pass  # one or more of the attributes was/were not defined, proceed with guest status
	except Exception as error:
		return helper.error_dump(error)


@app.after_view
def after_view(rv):
	return


@app.route('/favicon.ico')
def favicon():
	"""send the favicon from the typical location at /favicon.ico"""
	return send_from_directory(
		os.path.join(app.root_path, 'static'),
		'favicon.ico',
		mimetype='image/vnd.microsoft.icon',
		cache_timeout=60 * 60 * 24 * 365 * 5,  # set cache timeout to 5 years
	)


# @app.route('/<path:filename>', subdomain="static")
# def static(filename):
# 	"""send static files from separate sub-domain"""
# 	return send_from_directory(
# 		app.static_folder,
# 		filename,
# 	)


@app.route('/')
def index():
	return """
		<!DOCTYPE html>
		<html>
			<head>
				<title>CSD</title>
			</head>
			<body>
				<p>put docs generated by sphinx here</p>
			</body>
		</html>
	"""


@app.route('/json')
def json():
	return {'test': 42}


#TODO: add mongs like db browser, with option to only return json (read only?) (restricted - not able to read user collection)


# def cron():
# 	"""handles simple cron-like jobs such as rescraping"""
# 	print "cron jobs can be put here"
# 	t = Timer(10000, cron)
# 	t.start()

# cron()


# 	inputs = web.input(username='', token='')
# 	#only run user.check if username and token are defined... still allows use of default guest account


# app.add_processor(processor)


@app.route('/user/<action>')
def user_request(action):
	""" handles requests for user data, logins, and signups """
	print action

	if action == 'data':
		return g.user.safe_data()
	elif action == 'login':
		#CONSIDER: add a delay to prevent excessive attempts

		try:  # first try with email and password
			g.user.login(email=request.args['email'], password=request.args['password'], ip=request.remote_addr)
		except KeyError:
			try:  # otherwise try with username and password
				g.user.login(username=request.args['username'], password=request.args['password'], ip=request.remote_addr)
			except KeyError:
				return {'error': 'one or more of the required variables (username / email, and password) was/were not defined in your request'}
			except Exception as error:
				return helper.error_dump(error)  # bad info supplied
		except Exception as error:
			print error.args
			return helper.error_dump(error)  # bad info supplied

		return {'token': g.user.data['session']['token']}

	# signup and update are actually the same thing, just seperated in case I need to change something in the future
	elif action == 'signup' or action == 'update':
		try:
			g.user.update(request.args.data)
		except KeyError:
			return {'error': 'the data variable was not defined in your request'}
		except Exception as error:
			return helper.error_dump(error)
		return {'notify': 'update successful'}

	else:
		return abort(404)  # this means it is not one of the defined methods for interacting w/ the server


@app.route('/admin/task/<task>')
def admin_task(self, task):
	"""used for running admin tasks manually (they can also be triggered by cron/timed tasks)"""
	if g.user.can('run_admin_task'):
		#TODO: add code here
		return


if __name__ == "__main__":
	app.run(debug=True)
