#from threading import Timer
import model.helper as helper
import model.user as user
import db
from override_flask import Flask
from flask import request, g

app = Flask(__name__,)


@app.before_request
def before_request():
	g.notify = []  # an array that holds notifications (like non-fatal errors or important messages)

	# a variable that holds an error... if there is one (there should be 1 or 0 errors returned)
	# a error is formatted as ('title','discription')
	#	title: one word name for the error
	#	description: text given to the user to tell what happened / how to fix
	g.error = ()

	g.user = user.Instance()  # starts out as guest user, store user object in g (thread safe context)

	try:  # try to authenticate
		g.user.check(username=request.args['username'], token=request.args['token'], ip=request.remote_addr)  # validate user token if username and token are supplied
	except Exception as error:
		# the username / token didn't validate or one was not supplied - return the error
		# users must login with something to be able to access the database (even if it is the limited public "guest" account)
		return helper.error_dump(error)


@app.after_view
def after_view(rv):
	if not type(rv) in (dict, list):  # check to see that it's json, if not then return
		return
	#put stuff from g in response
	return


@app.route('/')
def index():
	return """
		<!DOCTYPE html>
		<html>
			<head>
				<title>CSD</title>
			</head>
			<body>
				<p>put docs generated by sphinx here?</p>
			</body>
		</html>
	"""


@app.route('/test')
def test():
	import model.scraper.scraper as scraper
	scraper.event_names(request.args.get('year'))
	return 'done'


@app.route('/reset')
def reset():
	import setup as setup
	setup.setup()
	return 'done'

#TODO: add mongs like db browser, with option to only return json (read only?) (restricted - not able to read user collection)


# def cron():
# 	"""handles simple cron-like jobs such as rescraping"""
# 	print "cron jobs can be put here"
# 	t = Timer(10000, cron)
# 	t.start()

# cron()


@app.route('/user/account')
def user_account():
	return g.user.safe_data()


@app.route('/user/login')
def user_login():
	#CONSIDER: add a delay to prevent excessive attempts

	try:
		helper.check_args(('username', 'password'), request.args)
	except Exception as error:
		return helper.error_dump(error)

	try:
		g.user.login(username=request.args['username'], password=request.args['password'], ip=request.remote_addr)
	except Exception as error:
		return helper.error_dump(error)  # bad info supplied

	return {'token': g.user.data['session']['token']}


@app.route('/user/update')
@app.route('/user/signup')
def user_update():
	# signups are really just updates on a non-existant user (for now)
	# the urls are seperated in case something needs to be changed

	try:
		helper.check_args(('data'), request.args)
	except Exception as error:
		return helper.error_dump(error)

	try:
		g.user.update(request.args['data'])
	except Exception as error:
		return helper.error_dump(error)

	return {'notify': 'update/signup successful'}


@app.route('/admin/task/reset')
def reset_db():

	if not g.user.can('run_admin_task'):
		return {'error': 'invalid permissions'}

	db.reset()
	return {'notify': 'reset successful'}


if __name__ == "__main__":
	app.run(
		debug=True,
		host='0.0.0.0',  # make dev server public
	)
